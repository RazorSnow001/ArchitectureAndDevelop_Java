Use patterns—Users expect millisecond response times and 100 percent uptime.
This situation has become evident especially now that mobile devices
are the biggest source of internet traffic, and things can only worsen in the near future
when such traffic is overtaken by the Internet of Things (IoT).


Reactive programming addresses these issues by allowing you to process and combine
streams of data items coming from different systems and sources in an asynchronous way.

The main feature of reactive programming for application-level components allows
tasks to be executed asynchronously

 As we discuss in the rest of this chapter, processing streams of events in an asynchronous and nonblocking way is essential for maximizing the use rate of modern multicore CPUs and, more precisely, of the threads
competing for their use

To achieve this goal, the reactive frameworks and libraries
share threads (relatively expensive and scarce resources) among lighter constructs
such as futures; actors; and (more commonly) event loops dispatching a sequence of
callbacks intended to aggregate, transform, and manage the events to be processed.

y is essential for maximizing the use rate of modern multicore CPUs and, more precisely, of the threads
competing for their use. T

but also have
a major advantage from developers’ point of view: they raise the level of abstraction of
implementing concurrent and asynchronous applications, a

allowing developers to concentrate on the business requirements instead of dealing with
 typical problems of lowlevel multithreading issues such as synchronization, race conditions, and deadlocks.

Reactive at application level

whereas events are facts that will
be received by the components that are registered to observe them